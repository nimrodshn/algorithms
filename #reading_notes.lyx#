#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\begin_local_layout
# Algorithm textclass definition file. Taken from initial LyX source code
# Author:  BG <nicolas.marsgui@libertysurf.fr>
# Version: 0.3

# This file contains a text style related to the algorithm and algorithmic
# packages, in order to write some algorithms through lyx.

Format 66
Style Algorithm
#  Margin               First_Dynamic
  LatexType             Item_Environment
  LatexName             algor
  NextNoIndent          1
  LeftMargin            MM
  LabelSep              xxx
  ItemSep               0
  TopSep                0.5
  BottomSep             0.5
  ParSep                0
  Align                 Block
  AlignPossible         Block, Left
  LabelType             Manual
  LabelString           MM
  FreeSpacing           0

  # label font definition
  LabelFont
    Series              Bold
  EndFont

  Preamble
    \usepackage{algolyx}
  EndPreamble
End

Style Algorithm_(num)
  CopyStyle             Algorithm
  LatexParam            [1]

End
\end_local_layout
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Introduction to Algorithms - Reading Notes & Selected Solutions
\end_layout

\begin_layout Author
Nimrod Shneor
\end_layout

\begin_layout Part*
\begin_inset Newpage pagebreak
\end_inset

Chapter 2
\end_layout

\begin_layout Section*
Solutions to selected exercises:
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
2.1-1 
\begin_inset Formula 
\begin{align*}
A & =[31,41,59,26,41]\\
A & =[31,41,59,26,41]\\
A & =[31,41,26,59,41]\\
A & =[31,26,41,59,41]\\
A & =[26,31,41,59,41]\\
A & =[26,31,41,41,59]
\end{align*}

\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
2.1-4 
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
BinaryAddition(A,B,n)
\end_layout

\end_inset


\end_layout

\begin_layout Algorithm
* 
\begin_inset Formula $carry\gets0$
\end_inset


\end_layout

\begin_layout Algorithm
for 
\begin_inset Formula $i\gets1$
\end_inset

 to 
\begin_inset Formula $n$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Algorithm
* 
\begin_inset Formula $C[i]\gets(A[i]+B[i]+C[i])\,mod2$
\end_inset


\end_layout

\begin_layout Algorithm
* 
\begin_inset Formula $carry\gets A[i]*B[i]$
\end_inset


\end_layout

\end_deeper
\begin_layout Algorithm
endfor
\end_layout

\begin_layout Algorithm
* 
\begin_inset Formula $C[i+1]\gets carry$
\end_inset


\end_layout

\begin_layout Algorithm
* return 
\begin_inset Formula $C$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Input: two 
\begin_inset Formula $n$
\end_inset

-bit numbers 
\begin_inset Formula $A,\,B$
\end_inset

.
\end_layout

\begin_layout Itemize
Output: the sum of 
\begin_inset Formula $A,B$
\end_inset

 - an 
\begin_inset Formula $n+1$
\end_inset

-bit number.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
2.2-3 Define 
\begin_inset Formula $X$
\end_inset

 = The number of elements checked in a 
\begin_inset Quotes eld
\end_inset

brute force
\begin_inset Quotes erd
\end_inset

 linear search.
\end_layout

\begin_layout Standard
Than 
\begin_inset Formula $X\in\{1...n\}$
\end_inset

 and the average number of elements checked in a linear search is exactly:
\begin_inset Formula 
\[
E[X]=\sum_{i=1}^{n}\frac{1}{n}i=\frac{1}{n}\sum_{i=1}^{n}i=\frac{n(n-1)}{2n}=\Theta(n)
\]

\end_inset


\end_layout

\begin_layout Standard
The worst case is where the last element of the array is the one searched
 for - resulting in an 
\begin_inset Formula $\Theta(n)$
\end_inset

 run time.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
2.3-3 
\begin_inset Formula 
\[
T(n)=\begin{cases}
2 & n=2\\
2T(\frac{n}{2})+n & n>2
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
Q: Proof by induction that if n is an exact power of two (that is 
\begin_inset Formula $n=2^{k}$
\end_inset

 for some constant 
\begin_inset Formula $k\geq1$
\end_inset

) than 
\begin_inset Formula $T(n)=nlogn$
\end_inset

.
\end_layout

\begin_layout Standard
Proof: By induction.
\end_layout

\begin_layout Standard
Base case: for 
\begin_inset Formula $k=1$
\end_inset

 than 
\begin_inset Formula $T(n)=2=2log2=nlogn$
\end_inset


\end_layout

\begin_layout Standard
Assumption: Assume the above holds for all integers up to 
\begin_inset Formula $k>1$
\end_inset

.
\end_layout

\begin_layout Standard
Induction step: We now prove the statement for 
\begin_inset Formula $n=2^{k+1}$
\end_inset

.
\end_layout

\begin_layout Standard
Plugging in to the formula 
\begin_inset Formula 
\begin{align*}
T(n) & =2T(\frac{n}{2})+n=2T(\frac{2^{k+1}}{2})+2^{k+1}\\
= & \,2T(2^{k})+2^{k+1}=2*2^{k}log2^{k}+2^{k+1}\\
= & \,k2^{k+1}+2^{k+1}=(k+1)2^{k+1}=2^{k+1}log2^{k+1}\\
= & \,nlogn
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
2.3-5 
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
BinarySearch(A,x)
\end_layout

\end_inset


\end_layout

\begin_layout Algorithm
* 
\begin_inset Formula $l\gets0$
\end_inset


\end_layout

\begin_layout Algorithm
* 
\begin_inset Formula $r\gets length(A)$
\end_inset


\end_layout

\begin_layout Algorithm
while 
\begin_inset Formula $l<r-1$
\end_inset


\end_layout

\begin_deeper
\begin_layout Algorithm
if 
\begin_inset Formula $x=A[\frac{l+r}{2}]$
\end_inset


\end_layout

\begin_deeper
\begin_layout Algorithm
return 
\begin_inset Formula $\frac{l+r}{2}$
\end_inset


\end_layout

\end_deeper
\begin_layout Algorithm
endif
\end_layout

\begin_layout Algorithm
if 
\begin_inset Formula $x>A[\frac{l+r}{2}]$
\end_inset


\end_layout

\begin_deeper
\begin_layout Algorithm
* 
\begin_inset Formula $l=A[\frac{l+r}{2}]$
\end_inset


\end_layout

\end_deeper
\begin_layout Algorithm
else
\end_layout

\begin_deeper
\begin_layout Algorithm
* 
\begin_inset Formula $r=A[\frac{l+r}{2}]$
\end_inset


\end_layout

\end_deeper
\begin_layout Algorithm
endif
\end_layout

\end_deeper
\begin_layout Algorithm
endwhile
\end_layout

\begin_layout Algorithm
* return -1
\end_layout

\end_inset


\end_layout

\begin_layout Standard
At each iteration of the while loop the distance between the two pointers
 - 
\begin_inset Formula $l,r$
\end_inset

 - is halfed until the element is found or we return -1.
 The while loop will terminate once the two pointers are at distance two
 at which point either the element 
\begin_inset Formula $x$
\end_inset

 is found or the loop will terminate.
 Thus the distance between the two pointers at each iteration 
\begin_inset Formula $i$
\end_inset

 is percisly 
\begin_inset Formula $\frac{length(A)}{2^{i}}=\frac{n}{2^{i}}$
\end_inset


\end_layout

\begin_layout Standard
At the time of the termination the distance between the two pointers is
 two, thus -
\begin_inset Formula 
\begin{align*}
\frac{n}{2^{i}} & =2\\
n & =2^{i+1}\\
log(n) & =i+1\\
log(n)-1 & =i\\
\text{\ensuremath{\Theta(log(n))}} & =i
\end{align*}

\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
2.3-7 
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
FindSum(A,x)
\end_layout

\end_inset


\end_layout

\begin_layout Algorithm
* 
\begin_inset Formula $B\gets MergeSort(A)$
\end_inset


\end_layout

\begin_layout Algorithm
* 
\begin_inset Formula $l\gets0$
\end_inset


\end_layout

\begin_layout Algorithm
* 
\begin_inset Formula $r\gets length(B)$
\end_inset


\end_layout

\begin_layout Algorithm
while 
\begin_inset Formula $l<r$
\end_inset


\end_layout

\begin_deeper
\begin_layout Algorithm
if 
\begin_inset Formula $B[l]+B[r]==x$
\end_inset


\end_layout

\begin_deeper
\begin_layout Algorithm
* return true
\end_layout

\end_deeper
\begin_layout Algorithm
elseif 
\begin_inset Formula $B[l]+B[r]<x$
\end_inset


\end_layout

\begin_deeper
\begin_layout Algorithm
* 
\begin_inset Formula $l\gets l+1$
\end_inset


\end_layout

\end_deeper
\begin_layout Algorithm
else 
\end_layout

\begin_deeper
\begin_layout Algorithm
* 
\begin_inset Formula $r\gets r-1$
\end_inset


\end_layout

\end_deeper
\begin_layout Algorithm
endif
\end_layout

\end_deeper
\begin_layout Algorithm
endwhile
\end_layout

\begin_layout Algorithm
* return false
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Solutions to selected problems:
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
2-1 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
a Given 
\begin_inset Formula $\frac{n}{k}$
\end_inset

 lists each of size 
\begin_inset Formula $k$
\end_inset

.
 Applying 
\begin_inset Formula $InsertionSort$
\end_inset

 to each list seperatly yealds worst-case runtime of 
\begin_inset Formula $\Theta(k^{2})$
\end_inset

.
 Doing this for all 
\begin_inset Formula $\frac{n}{k}$
\end_inset

 lists yealds an 
\begin_inset Formula $\Theta(\frac{n}{k}k^{2})=\Theta(nk)$
\end_inset

 runtime algorithm.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
b 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
ModifiedMergeSort(A)
\end_layout

\end_inset


\end_layout

\begin_layout Algorithm
* Split 
\begin_inset Formula $A$
\end_inset

 to form 
\begin_inset Formula $S=[A_{1},..,A_{\frac{n}{k}}]$
\end_inset

 array of sub-arrays of size 
\begin_inset Formula $k$
\end_inset


\end_layout

\begin_layout Algorithm
for 
\begin_inset Formula $i\gets1$
\end_inset

 to 
\begin_inset Formula $\frac{n}{k}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Algorithm
* 
\begin_inset Formula $A_{i}\gets InsertionSort(A_{i})$
\end_inset


\end_layout

\end_deeper
\begin_layout Algorithm
endfor
\end_layout

\begin_layout Algorithm
while 
\begin_inset Formula $|S|>1$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Algorithm
* 
\begin_inset Formula $l\gets1$
\end_inset


\end_layout

\begin_layout Algorithm
* 
\begin_inset Formula $r\gets\frac{n}{\text{|S|}}$
\end_inset


\end_layout

\begin_layout Algorithm
* 
\begin_inset Formula $S'\gets\Phi$
\end_inset


\end_layout

\begin_layout Algorithm
while 
\begin_inset Formula $l<r$
\end_inset


\end_layout

\begin_deeper
\begin_layout Algorithm
* 
\begin_inset Formula $S'\gets S'\bigcup Merge(A_{l},A_{r})$
\end_inset


\end_layout

\begin_layout Algorithm
* 
\begin_inset Formula $l\gets l+1$
\end_inset


\end_layout

\begin_layout Algorithm
* 
\begin_inset Formula $r\gets r-1$
\end_inset


\end_layout

\end_deeper
\begin_layout Algorithm
endwhile
\end_layout

\begin_layout Algorithm
* 
\begin_inset Formula $S\gets S'$
\end_inset


\end_layout

\end_deeper
\begin_layout Algorithm
endwhile
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Merging two sublist of size 
\begin_inset Formula $k$
\end_inset

 using the 
\begin_inset Formula $Merge$
\end_inset

 algorithm runs in 
\begin_inset Formula $\Theta(k)$
\end_inset

.
 Next we prove that at each of the outer loop iteration the size of 
\begin_inset Formula $|S|$
\end_inset

 is 
\begin_inset Formula $\frac{n}{2^{i}k}$
\end_inset

.
\end_layout

\begin_layout Standard
Proof: By induction,
\end_layout

\begin_layout Standard
Base 
\begin_inset Formula $i=1$
\end_inset

: In the first iteration we set 
\begin_inset Formula $l$
\end_inset

 and 
\begin_inset Formula $r$
\end_inset

 to hold the two opposit ends of 
\begin_inset Formula $S$
\end_inset

, at each iteration we merge two subsets and continue so on until 
\begin_inset Formula $l=r$
\end_inset

 or 
\begin_inset Formula $l>r$
\end_inset

 (depending on the number of subsets) because at each iteration we merged
 two subsets the number of iterations of the inner loop is percisly 
\begin_inset Formula $\frac{n}{2k}$
\end_inset

.
\end_layout

\begin_layout Standard
Step: Assume that the number of subsets in 
\begin_inset Formula $|S|$
\end_inset

 is 
\begin_inset Formula $\frac{n}{2^{i}k}$
\end_inset

 at iteration 
\begin_inset Formula $i$
\end_inset

 next we prove that at iteration 
\begin_inset Formula $i+1$
\end_inset

 the above statement holds.
\end_layout

\begin_layout Standard
Again, from the same argument for the base case - at each iteration of the
 inner loop the number of elements decrease by two the number of iterations
 of the inner loop is 
\begin_inset Formula $\frac{n}{2^{i+1}k}$
\end_inset

 yeilding that number of subsets.
 
\end_layout

\begin_layout Standard
The outer loop will terminate once 
\begin_inset Formula $|S|=1$
\end_inset

, that is -
\begin_inset Formula 
\begin{align*}
\frac{n}{2^{i}k} & =1\\
\frac{n}{k} & =2^{i}\\
log(\frac{n}{k})= & i
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
At each iteration we perform 
\begin_inset Formula $\frac{n}{2^{i}k}$
\end_inset

 merges each runs in 
\begin_inset Formula $\Theta(k)$
\end_inset

 for a total of 
\begin_inset Formula $\Theta(\frac{n}{2^{i}k}k)$
\end_inset


\end_layout

\begin_layout Standard
All together we get 
\begin_inset Formula $\Theta(nlog\frac{n}{k})+\Theta(nk)$
\end_inset

.
\end_layout

\end_body
\end_document
